CREAZIONE E STAMPA DEL TABELLONE DI GIOCO
=========================================

vedere "./common/globals.txt"
vedere "./common/records.txt"
vedere "./common/string.txt"
vedere "./common/math.txt"

Creazione e stampa del tabellone di gioco con le funzioni necessarie per
l'inizializzazione dello stesso e aggiunta di caselle speciali.

Le funzioni incluse in questo file permettono di definire la dimensione del
tabellone, inserire caselle oca e speciali, inserire quest'ultime in maniera
proporzionale al numero di caselle del tabellone senza creare conflitti con le
caselle oca.

LAVORO:
- num_squares, il numero di caselle scelto dal giocatore, intero compreso tra
  MIN_NUM_SQUARES e MAX_NUM_SQUARES inclusi;
- board, il tabellone di gioco dove si svolgerà la partita, Board.

ALGORITMO:
num_squares := get_num_squares()
board := create_board(num_squares)
print_board(board, DEFAULT_COLS, DEFAULT_SQUARE_LEN, DEFAULT_BORDERS)


--------------------------------------------------------------------------------


FUNZIONE get_num_squares()
==========================

Richiede all'utente di inserire il numero di caselle del tabellone di gioco e
restituisce il valore inserito.

OUTPUT:
- num_squares, il numero di caselle scelto dal giocatore, intero compreso tra
  MIN_NUM_SQUARES e MAX_NUM_SQUARES inclusi.

ALGORITMO:
StampareAVideo("Inserici il numero di caselle [50, 90]:")
num_squares := LeggereDaTastiera()
MENTRE ((num_squares < MIN_NUM_SQUARES) OR (num_squares > MAX_NUM_SQUARES))
  StampareAVideo("Il numero inserito non è valido.")
  StampareAVideo("Inserici il numero di caselle [50, 90]:")
  num_squares := LeggereDaTastiera()
FINE


------------------------------------------------------------


FUNZIONE create_board()
=======================

Crea un tabellone vuoto con la dimensione data, lo riempie di caselle e inserisce
le caselle oca e caselle speciali.

INPUT:
- dimension, dimensione del tabellone di gioco che va creato, intero maggiore
  di zero

OUTPUT:
- game_board, tabellone con tutte le caselle inserite, Board.

LAVORO:
- i, contatore delle caselle del tabellone di gioco, intero maggiore di zero.

ALGORITMO:
set_dim(game_board, dimension)
i := 0
MENTRE (i < dimension)
  set_square(game_board, i, i + 1);
  i := i + 1;
FINE
game_board := insert_goose_squares(game_board)
game_board := insert_special_squares(game_board)


FUNZIONE insert_goose_squares()
===============================

Aggiunge le caselle oca al tabellone di gioco, a partire dalla casella con
indice GOOSE_SPACING, con un intervallo tra di esse sempre pari a GOOSE_SPACING.

INPUT:
- board, il tabellone di gioco dove si svolgerà la partita, Board.

OUTPUT:
- board, tabellone di gioco dove si svolgerà la partita con le caselle oca, Board.

LAVORO:
- num_squares, il numero di caselle scelto dal giocatore, intero compreso tra
  MIN_NUM_SQUARES e MAX_NUM_SQUARES inclusi.
- i, contatore delle caselle del tabellone di gioco, intero maggiore o uguale
  a GOOSE_SPACING.

ALGORITMO:
num_squares := get_dim(board)
i := GOOSE_SPACING;
MENTRE (i < num_squares)
  set_square(board, i, GOOSE_VALUE)
  i := i + GOOSE_SPACING;
FINE


FUNZIONE insert_special_squares()
=================================

Inserisce le caselle speciali nel tabellone di gioco.

INPUT:
- board, tabellone di gioco dove si svolgerà la partita, Board.

OUTPUT:
- board, tabellone di gioco dove si svolgerà la partita con caselle oca e
  speciali, Board.

LAVORO:
- board_dim, il valore della dimensione del tabellone di gioco, intero maggiore
  di zero.

ALGORITMO:
board_dim := get_dim(board)

bridge_position := proportion(BRIDGE_SQUARE, board_dim, MAX_NUM_SQUARES)
bridge_position := check_special_square(bridge_position, board)
set_square(board, bridge_position, BRIDGE_VALUE)

inn_position := proportion(INN_SQUARE, board_dim, MAX_NUM_SQUARES)
inn_position := check_special_square(inn_position, board)
set_square(board, inn_position, INN_VALUE)

well_position := proportion(WELL_SQUARE, board_dim, MAX_NUM_SQUARES)
well_position := check_special_square(well_position, board)
set_square(board, well_position, WELL_VALUE)

labyrinth_position := proportion(LABYRINTH_SQUARE, board_dim, MAX_NUM_SQUARES)
labyrinth_position := check_special_square(labyrinth_position, board)
set_square(board, labyrinth_position, LABYRINTH_VALUE)

prison_position := proportion(PRISON_SQUARE, board_dim, MAX_NUM_SQUARES)
prison_position := check_special_square(prison_position, board)
set_square(board, prison_position, PRISON_VALUE)

skeleton_position := proportion(SKELETON_SQUARE, board_dim, MAX_NUM_SQUARES)
skeleton_position := check_special_square(skeleton_position, board)
set_square(board, skeleton_position, SKELETON_VALUE)


FUNZIONE is_goose_square()
--------------------------

Verica se una casella del tabellone è una casella oca o meno.

INPUT:
- board, il tabellone di gioco dove si svolgerà la partita, Board;
- position, posizione della casella del tabellone di cui verificare se sia oca o
  meno, intero maggiore di zero.

OUTPUT:
- esito, booleano che assume valore 1 se la casella "square" è una casella oca,
  0 altrimenti.

ALGORITMO:
square := get_square(board, position)
SE (square = GOOSE_VALUE)
   ALLORA esito := 1
   ALTRIMENTI esito := 0
FINE


FUNZIONE check_special_square()
-------------------------------

Verifica se la posizione della casella speciale nel tabellone di gioco crea un
conflitto con una casella oca.

INPUT:
- special_square, posizione della casella speciale all'interno del tabellone di
  gioco, intero maggiore di zero;
- board, il tabellone di gioco dove si svolgerà la partita, Board.

OUTPUT:
- allowed_special_pos, posizione della casella speciale che non crea conflitto
  con le caselle oca, intero maggiore di zero.

ALGORITMO:
allowed_special_pos := special_square
SE (is_goose_square(special_square, board) = 1)
  ALLORA
    allowed_special_pos := allowed_special_pos + 1
FINE


------------------------------------------------------------


FUNZIONE print_board()
======================

INPUT:
- board, tabellone di gioco su cui si svolgerà la partita, Board.
- cols, numero di colonne che il tabellone deve avere, intero maggiore di zero;
- square_len, lunghezza desiderata della singola casella, intero maggiore di zero;
- borders, definisce quali caratteri utilizzare per costruire il bordo, array di
  massimo otto caratteri che segue il seguente ordine: nw_corner (es. "┌"),
  ne_corner (es. "┐"), sw_corner (es. "└"), se_corner (es. "┘"),
  join_down (es. "┬"), join_up (es. "┴"), dash (es. "─"), vert (es. "│"),

OUTPUT:
- nullo, non restituisce niente, vuoto.

LAVORO:
- game_board, tabellone di gioco generato, stringa.

ALGORITMO:
game_board := build_board(board, cols, square_len, borders)
StampareAVideo(game_board)


FUNZIONE build_border()
-----------------------

INPUT:
- borders, lista di caratteri da utilizzare per il bordo, array di caratteri che
  deve seguire il seguente ordine: west_char, east_char, join_char, dash_char;
- square_len, lunghezza desiderata della singola casella, intero maggiore di zero;
- cols, numero di colonne con cui costruire il tabellone, intero maggiore di zero;
- rows, numero di righe con cui costruire il tabellone, intero maggiore di zero;
- row, colonna corrente all'interno del tabellone, intero maggiore di zero;
- board, tabellone di gioco su cui si svolge la partita, Board.

OUTPUT:
- buffer, bordo che è stato costruito secondo i dati di input, stringa.

LAVORO:
- ndash, parte del bordo che contiene solo dash_char, stringa;
- square_size, dimensione effettiva della casella, intero maggiore di zero;
- board_dim, dimensione del tabellone di gioco, intero maggiore di zero;
- col, contatore per iterare sul numero di colonne, intero maggiore o uguale a
  zero;
- pos, valore della posizione all'interno del tabellone, intero maggiore di zero;
- is_last_of_row, indica se la casella è l'ultima della riga, booleano che assume
  valore 1 se vero, 0 altrimenti;
- is_fist, indica se la casella è la prima del tabellone, booleano che assume
  valore 1 se vero, 0 altrimenti;

ALGORITMO:
ndash := str_nconcat(ndash, dash_char, square_len - 1)
square_size := 1 + square_len * str_length(west_char);
board_dim := get_dim(board);

col := 0;
MENTRE (col < cols)
  SE (mod(row, 2) == 0) {
    ALLORA
      pos := row * cols + col;
      is_last_of_row :=
          ((col = cols - 1) AND (row <> rows - 1)) OR (pos = board_dim - 1)

      SE (col == 0)                             // 1st sq of the row
        ALLORA
          str_concat(buffer, west_char)
          str_concat(buffer, ndash)
        ALTRIMENTI SE (is_last_of_row)          // last sq of the row
          ALLORA
            str_concat(buffer, join_char)
            str_concat(buffer, ndash)
            str_concat(buffer, east_char)
          ALTRIMENTI SE (pos < board_dim - 1)   // between 1st & last
            ALLORA
              str_concat(buffer, join_char)
              str_concat(buffer, ndash)
            ALTRIMENTI                          // when traveling RtL
              str_nconcat(buffer, SPACE_CHAR, square_len)
            FINE
          FINE
        FINE
      FINE
  ALTRIMENTI
    pos = (row + 1) * cols - col - 1;
    is_fist = (col == 0) && (row != rows - 1);

    SE (is_fist OR pos = board_dim - 1)       // 1st sq of the row and last sq
      ALLORA
        str_concat(buffer, west_char)
        str_concat(buffer, ndash)
      ALTRIMENTI SE (col = cols - 1)          // last sq of the row
        ALLORA
          str_concat(buffer, east_char)
          str_concat(buffer, ndash)
          str_concat(buffer, join_char)
        ALTRIMENTI SE (pos < board_dim - 1)   // between 1st & last
          ALLORA
            str_concat(buffer, east_char)
            str_concat(buffer, ndash)
          ALTRIMENTI                          // when traveling LtR
            str_nconcat(buffer, SPACE_CHAR, square_len)
        FINE
      FINE
    FINE
  FINE
  col := col + 1
FINE
str_concat(buffer, LINE_END)


FUNZIONE square_to_str()
------------------------

INPUT:
- square, valore della casella del tabellone, intero maggiore di zero;

OUTPUT:
- buffer, valore della casella del tabellone, stringa.

ALGORITMO:
SE (square = GOOSE_VALUE)
  ALLORA str_concat(buffer, "X2")
  ALTRIMENTI SE (square = BRIDGE_VALUE)
    ALLORA str_concat(buffer, "BR")
    ALTRIMENTI SE (square = INN_VALUE)
      ALLORA str_concat(buffer, "IN")
      ALTRIMENTI SE (square = WELL_VALUE)
        ALLORA str_concat(buffer, "WE")
        ALTRIMENTI SE (square = LABYRINTH_VALUE)
          ALLORA str_concat(buffer, "LA")
          ALTRIMENTI SE (square = PRISON_VALUE)
            ALLORA str_concat(buffer, "PR")
            ALTRIMENTI SE (square = SKELETON_VALUE)
              ALLORA str_concat(buffer, "SK")
              ALTRIMENTI str_concat(buffer, ConvertireInStringa(square))
            FINE
          FINE
        FINE
      FINE
    FINE
  FINE
FINE


FUNZIONE build_squares()
------------------------

INPUT:
- vert, separatore verticale da utilizzare, carattere;
- square_len, lunghezza desiderata della singola casella, intero maggiore di zero;
- cols, numero di colonne del tabellone di gioco, intero maggiore di zero;
- rows, numero di righe del tabellone di gioco, intero maggiore di zero;
- row, riga corrente del tabellone, intero maggiore o uguale a zero;
- board, tabellone di gioco su cui si svolgerà la partita, Board.

OUTPUT:
- buffer, caselle per la riga row del tabellone, stringa.

LAVORO:
- board_dim, numero di caselle del tabellone di gioco, intero maggiore o uguale
  a MIN_NUM_SQUARES e minore o uguale di MAX_NUM_SQUARES;
- lspacing, numero di spazi da inserire tra vert e il valore della casella, intero
  maggiore di zero;
- rspacing, numero di spazi da inserire tra il valore della casella e vert, intero
  maggiore di zero;
- col, numero corrente della colonna, intero maggiore o uguale a zero;
- pos, posizione all'interno del tabellone, intero maggiore di zero;
- square, valore della casella del tabellone, intero maggiore o uguale a zero;
- sq, valore di square convertito a stringa, stringa;
- is_fist, indica se la casella è la prima del tabellone, booleano che assume
  valore 1 se vero, 0 altrimenti;
- is_last, indica se la casella è l'ultima del tabellone, booleano che assume
  valore 1 se vero, 0 altrimenti;

ALGORITMO:
board_dim := get_dim(board)
lspacing := (square_len - 3) / 2;
SE (mod(square_len, 2) <> 0)
  ALLORA rspacing := lspacing
  ALTRIMENTI rspacing := lspacing + 1
FINE

col := 0
MENTRE (col < cols)
  SE (mod(row, 2) = 0)
    ALLORA
      pos := row * cols + col
      square := get_square(board, pos)
      sq := square_to_str(square)

      is_first := (col = cols - 1) AND (row <> rows - 1)
      is_last := (pos = board_dim - 1) AND (row = rows - 1)

      SE (is_fist || is_last)
        ALLORA
          str_concat(buffer, vert)
          str_nconcat(buffer, SPACE_CHAR, lspacing)
          str_concat(buffer, sq)
          str_nconcat(buffer, SPACE_CHAR, rspacing)
          str_concat(buffer, vert)
        ALTRIMENTI SE (pos < board_dim)
          ALLORA
            str_concat(buffer, vert)
            str_nconcat(buffer, SPACE_CHAR, lspacing)
            str_concat(buffer, sq)
            str_nconcat(buffer, SPACE_CHAR, rspacing)
          ALTRIMENTI
            str_nconcat(buffer, SPACE_CHAR, square_len)
        FINE
      FINE
    ALTRIMENTI
      pos := (row + 1) * cols - col - 1
      square := get_square(board, pos)
      sq := square_to_str(square)

      SE (col = cols - 1)
        ALLORA
          str_concat(buffer, vert)
          str_nconcat(buffer, SPACE_CHAR, lspacing)
          str_concat(buffer, sq)
          str_nconcat(buffer, SPACE_CHAR, rspacing)
          str_concat(buffer, vert)
        ALTRIMENTI SE (pos < board_dim)
          ALLORA
            str_concat(buffer, vert)
            str_nconcat(buffer, SPACE_CHAR, lspacing)
            str_concat(buffer, sq)
            str_nconcat(buffer, SPACE_CHAR, rspacing)
          ALTRIMENTI
            str_nconcat(buffer, SPACE_CHAR, square_len)
        FINE
      FINE
  FINE
  col := col + 1
FINE
str_concat(buffer, LINE_END)


FUNZIONE build_board()
----------------------

INPUT:
- board, tabellone di gioco su cui si svolgerà la partita, Board;
- cols, numero di colonne con cui stampare il tabellone, intero maggiore di zero;
- square_len, lunghezza desiderata della singola casella, intero maggiore di zero;
- borders, definisce quali caratteri utilizzare per costruire il bordo, array di
  massimo otto caratteri che segue il seguente ordine: nw_corner (es. "┌"),
  ne_corner (es. "┐"), sw_corner (es. "└"), se_corner (es. "┘"),
  join_down (es. "┬"), join_up (es. "┴"), dash (es. "─"), vert (es. "│").

OUTPUT:
- game_board,

LAVORO:
- rows, il numero di colonne che il tabellone possiederà, intero maggiore di zero;
- top_borders, i caratteri che il bordo superiore utilizza, array di caratteri;
- bot_borders, i caratteri che il bordo inferiore utilizza, array di caratteri;
- top, bordo superiore del tabellone per la riga row, stringa;
- squares, caselle del tabellone per la riga row, stringa;
- bot, bordo inferiore del tabellone per la tiga row, stringa.

ALGORITMO:
rows := (get_dim(board) + cols - 1) / cols  // calculate needed rows
top_borders := {nw_corner, ne_corner, join_down, dash}
bot_borders := {sw_corner, se_corner, join_up, dash}

row := 0;
MENTRE (row < rows)
  top = build_border(top_borders, square_len, cols, rows, row, board)
  str_concat(game_board, top)

  squares = build_squares(vert, square_len, cols, rows, row, board)
  str_concat(game_board, squares)

  bot = build_border(bot_borders, square_len, cols, rows, row, board)
  str_concat(game_board, bot)

  row := row + 1
FINE
