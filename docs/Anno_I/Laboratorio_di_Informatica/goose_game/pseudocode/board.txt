CREAZIONE E STAMPA DEL TABELLONE DI GIOCO
=========================================

vedere "globals.txt"
vedere "records.txt"
vedere "utils/string.txt"

Creazione e stampa del tabellone di gioco con le funzioni necessarie per 
l'inizializzazione dello stesso e aggiunta di caselle speciali.

Le funzioni incluse in questo file permettono di definire la dimensione del 
tabellone, inserire caselle oca e speciali, inserire quest'ultime in maniera
proporzionale al numero di caselle del tabellone senza creare conflitti con le 
caselle oca.

LAVORO:
- num_squares, il numero di caselle scelto dal giocatore, intero compreso tra
  MIN_NUM_SQUARES e MAX_NUM_SQUARES inclusi;
- board, il tabellone di gioco dove si svolgerà la partita, Board.

ALGORITMO:
num_squares := get_num_squares()
board := create_board(num_squares)
print_board(board)


--------------------------------------------------------------------------------


FUNZIONE get_num_squares()
==========================

Richiede all'utente di inserire il numero di caselle del tabellone di gioco e 
restituisce il valore inserito.

OUTPUT:
- num_squares, il numero di caselle scelto dal giocatore, intero compreso tra
  MIN_NUM_SQUARES e MAX_NUM_SQUARES inclusi.

ALGORITMO:
StampareAVideo("Inserici il numero di caselle [50, 90]:")
num_squares := LeggereDaTastiera()
MENTRE ((num_squares < MIN_NUM_SQUARES) OR (num_squares > MAX_NUM_SQUARES))
  StampareAVideo("Il numero inserito non è valido.")
  StampareAVideo("Inserici il numero di caselle [50, 90]:")
  num_squares := LeggereDaTastiera()
FINE


------------------------------------------------------------


FUNZIONE create_board(dimension)
================================

Crea un tabellone vuoto con la dimensione data, lo riempie di caselle e inserisce
le caselle oca e caselle speciali.

INPUT:
- dimension, rappresenta la dimensione del tabellone da creare, intero maggiore
  di zero

OUTPUT:
- game_board, tabellone creato con le caselle inizializzate e le caselle oca e 
  speciali inserite, Board.

LAVORO:
- i, contatore delle caselle del tabellone di gioco, intero maggiore di zero.

ALGORITMO:
set_dim(game_board, dimension)
i := 0
MENTRE (i < dimension)
  set_square(game_board, i, i + 1);
  i := i + 1;
FINE
insert_goose_squares(game_board)
insert_special_squares(game_board)


FUNZIONE insert_goose_squares(board)
====================================

Aggiunge le caselle oca al tabellone di gioco, a partire dalla casella con indice 
GOOSE_SPACING, con un intervallo tra di esse sempre pari a GOOSE_SPACING.

INPUT:
- board, il tabellone di gioco dove si svolgerà la partita, Board.

OUTPUT:
- board, il tabellone di gioco dove si svolgerà la partita, modSEicato con 
  l'aggiunta delle caselle oca, Board.

LAVORO:
- num_squares, il numero di caselle scelto dal giocatore, intero compreso tra
  MIN_NUM_SQUARES e MAX_NUM_SQUARES inclusi.
- i, contatore delle caselle del tabellone di gioco, intero maggiore o uguale 
  a GOOSE_SPACING.

ALGORITMO:
num_squares := get_dim(board)
i := GOOSE_SPACING;
MENTRE (i < num_squares)
  set_square(board, i, GOOSE_VALUE)
  i := i + GOOSE_SPACING;
FINE


FUNZIONE insert_special_squares(board)
======================================

Inserisce le caselle speciali nel tabellone di gioco.

INPUT:
- board, il tabellone di gioco dove si svolgerà la partita, modSEicato con 
  l'aggiunta delle caselle oca. Board.

OUTPUT:
- board, il tabellone di gioco dove si svolgerà la partita, completo di 
  oca e speciali. Board.

ALGORITMO:
bridge_position := proportion(BRIDGE_SQUARE, new_board)
bridge_position := check_special_square(bridge_position, board)
set_square(board, bridge_position, BRIDGE_VALUE)

inn_position := proportion(INN_SQUARE, new_board)
inn_position := check_special_square(inn_position, new_board)
set_square(board, inn_position, INN_VALUE)

well_position := proportion(WELL_SQUARE, game_board)
well_position := check_special_square(well_position, game_board) 
set_square(board, well_position, WELL_VALUE)

labyrinth_position := proportion(LABYRINTH_SQUARE, game_board)
labyrinth_position := check_special_square(labyrinth_position, game_board)
set_square(board, labyrinth_position, LABYRINTH_VALUE)

prison_position := proportion(PRISON_SQUARE, game_board)
prison_position := check_special_square(prison_position, game_board)
set_square(board, prison_position, PRISON_VALUE)

skeleton_position := proportion(SKELETON_SQUARE, game_board)
skeleton_position := check_special_square(skeleton_position, game_board)
set_square(board, skeleton_position, SKELETON_VALUE)


FUNZIONE proportion(board, special_square)
------------------------------------------

Calcola il nuovo valore di posizione della casella speciale rapportato al
numero di caselle ricevute in input.

INPUT:
- board, il tabellone di gioco dove si svolgerà la partita, Board
- special_square, valore di posizione della casella speciale all'interno del 
  tabellone da gioco, intero maggiore di zero;

OUTPUT:
- new_special_square, nuovo valore di posizione della casella speciale rapportato
  al numero di caselle ricevute in input (num_squares), intero maggiore di zero.

ALGORITMO:
new_special_square := floor((special_square * get_dim(board)) / MAX_NUM_SQUARES)


FUNZIONE floor(float_num)
-------------------------

Converte un numero decimale in un intero, eliminando la parte decimale.

INPUT:
- float_num, numero decimale da convertire in intero, reale maggiore di zero.

OUTPUT:
- int_num, numero intero senza la parte decimale, intero maggiore di zero.

LAVORO:
- i, indice per scorrere gli interi, intero maggiore di zero.

ALGORITMO:
int_num := 1
i := 1
MENTRE (i <= float_num)
  SE (float_num > i)
    ALLORA int_num := i
  FINE
  i := i + 1
FINE


FUNZIONE is_goose_square(board, position)
-----------------------------------------

VerSEica se una casella del tabellone è una casella oca o meno.

INPUT:
- board, il tabellone di gioco dove si svolgerà la partita, Board.
- position, valore della posizione di una casella del tabellone di cui verSEicare 
  se sia casella oca o meno, intero maggiore di zero. 

OUTPUT:
- esito, booleano che assume valore 1 se la casella "square" è una casella oca,
  0 altrimenti.

ALGORITMO:
square := get_square(board, position)
SE (square = GOOSE_VALUE)
   ALLORA esito := 1
   ALTRIMENTI esito := 0
FINE


FUNZIONE check_special_square(board, special_position)
------------------------------------------------------

VerSEica se la posizione della casella speciale nel tabellone di gioco crea un 
conflitto con una casella oca.

INPUT:
- special_square, valore della posizione della casella speciale all'interno del 
  tabellone di gioco, intero maggiore di zero.
- board, il tabellone di gioco dove si svolgerà la partita, Board.

OUTPUT:
- allowed_special_pos, valore della posizione della casella speciale che 
  non crea alcun conflitto con le caselle oca. Intero maggiore di zero.

ALGORITMO:
allowed_special_pos := special_square
SE (is_goose_square(special_square, board) = 1) 
  ALLORA 
    allowed_special_pos := allowed_special_pos + 1
FINE


------------------------------------------------------------

FUNZIONE build_border(borders, square_len, cols, rows, row, board)
------------------------------------------------------------------

INPUT:
- borders, array di 4 stringhe che rappresentano i bordi da utilizzare nella
  creazione del bordo, array di strighe;
- square_len, lunghezza desiderata della singola casella, intero maggiore di 
  zero;
- cols, numero di colonne desiderato, intero maggiore di zero;
- rows, numero di righe desiderato, intero maggiore di zero;
- row, il valore della riga corrente;
- board, il tabellone di gioco su cui si svolgerà la partita.

OUTPUT:
- buffer, la stringa contenente il bordo che viene generato, stringa.

LAVORO:
- ndash, stringa che contiene il carattere che in borders rappresenta il trattino
  orizzontale ripetuto square_len - 1 volte, stringa;
- pos, posizione all'intero del tabellone, intero maggiore di zero;
- is_last_of_row, variabile booleana che determina se un elemento è l'ultimo 
  della riga, assume 1 se vero e 0 se falso, intero;
- is_first, variabile booleana che determina se un numero è il primo del 
  tabellone, assume 1 se vero e 0 se falso, intero:

ALGORITMO:
nconcat(ndash, borders[3], square_len - 1)
square_size := 1 + square_len * strlen(primo elemento di borders)
board_dim := get_dim(board)

col := 0
MENTRE (col < cols)
  SE (row mod 2 = 0)
    ALLORA
      pos := row * cols + col
      is_last_of_row := 
        ((col = cols - 1) AND (row <> rows - 1)) OR (pos = board_dim - 1)

      SE (col = 0)
        ALLORA
          fconcat(buffer, 2, {borders[0], ndash})
        ALTRIMENTI SE (is_last_of_row)
          ALLORA 
            fconcat(buffer, 3 {borders[2], ndash, borders[1]})
          ALTRIMENTI SE (pos < board_dim - 1)
            ALLORA
              fconcat(buffer, 2, {borders[2], ndash})
            ALTRIMENTI
              nconcat(buffer, " ", square_len)            
          FINE
        FINE
      FINE
    ALTRIMENTI
      pos := (row + 1) * cols - col - 1
      is_fist := (col = 0) AND (row <> rows - 1)

      SE (is_first OR pos = board_dim - 1)
        ALLORA
          fconcat(buffer, 2, {borders[0], ndash})
        ALTRIMENTI SE (col = cols - 1)
          ALLORA
            fconcat(buffer, 3 {borders[2], ndash, borders[1]})
          ALTRIMENTI SE (pos < board_dim - 1)
            ALLORA
              fconcat(buffer, 2 {borders[2], ndash});
            ALTRIMENTI
              nconcat(buffer, " ", square_len)
          FINE
        FINE
      FINE
  FINE
  col := col + 1
FINE
fconcat(buffer, 2, {STR_END, LINE_END})


FUNZIONE square_to_str(square)
==============================

INPUT:
- square, valore in una qualsiasi posizione del campo squares di un Board, 
  intero maggiore di zero.

OUTPUT:
- buffer, stringa che contiene il valore sotto forma di stringa di square, 
  stringa.

ALGORITMO:
SE (square = GOOSE_VALUE)
  ALLORA
      concat(buffer, "X2")
  ALTRIMENTI SE (square = BRIDGE_VALUE)
    ALLORA
      concat(buffer, "BR")
    ALTRIMENTI SE (square = INN_VALUE)
      ALLORA
        concat(buffer, "IN");
      ALTRIMENTI SE (square = WELL_VALUE)
        concat(buffer, "WE");
      ALTRIMENTI SE (square = LABYRINTH_VALUE)
        ALLORA
          concat(buffer, "LA");
        ALTRIMENTI SE (square = PRISON_VALUE)
          ALLORA
            concat(buffer, "PR");
          ALTRIMENTI SE (square = SKELETON_VALUE)
            ALLORA
              concat(buffer, "SK");
            ALTRIMENTI
              converti square in stringa
              concat(buffer, square);
          FINE
        FINE
      FINE
    FINE
  FINE
FINE


FUNZIONE build_board(board, cols, square_len, borders)
------------------------------------------------------

INPUT:
- board, il tabellone di gioco dove si svolgerà la partita che va stampato, Board;
- cols, numero di colonne desiderato per il tabellone, intero maggiore di zero;
- square_len, lunghezza desiderata della singola casella, intero maggiore di 
  zero;
- borders, lista di caratteri che formano il bordo del tabellone, l'ordine dei 
  singoli caratteri è arbitrario ed è il seguente:
  - 1 := nw_corner (es. "┌");
  - 2 := ne_corner (es. "┐");
  - 3 := sw_corner (es. "└");
  - 4 := se_corner (es. "┘");
  - 5 := join_down (es. "┬");
  - 6 := join_up   (es. "┴");
  - 7 := dash      (es. "─");
  - 8 := vert      (es. "│").

LAVORO:
- rows, numero di righe calcolato in base al numero di colonne ricevuto, intero
  maggiore di zero;
- top_borders, utilizzato per individuare i bordi superiori presenti all'interno 
  di borders, array di stringhe;
- bot_borders, utilizzato per individuare i bordi inferiori presenti all'interno 
  di borders, array di stringhe;
- vert, indica il separatore verticale, stringa.
- row, contatore utilizzato per iterare sulle righe del tabellone, intero 
  maggiore o uguale a zero;
- top, contiene il bordo ottenuto utilizzando top_borders, stringa;
- squares, contiene le caselle con il separatore verticale, stringa;
- bot, contiene il bordo ottenuto utilizzando bot_borders, stringa.

OUTPUT:
- game_board, il tabellone di gioco completo con bordi, caselle, caselle oca e 
  caselle speciali, stringa.

ALGORITMO:
rows = (get_dim(board) + cols - 1) / cols
top_borders = {primo elemento di borders, secondo elemento di borders,
               quinto elemento di borders, settimo elemento di borders}
bot_borders = {terzo elemento di borders, quarto elemento di borders, 
               sesto elemento di borders, settimo elemento di borders}
vert = ottavo elemento di borders

row = 0;
MENTRE (row < rows)
  top = build_border(top_borders, square_len, cols, rows, row, board);
  squares = build_squares(vert, square_len, cols, rows, row, board);
  bot = build_border(bot_borders, square_len, cols, rows, row, board);
  fconcat(game_board, 3, {top, squares, bot});

  row = row + 1;
FINE


FUNZIONE print_board()
======================

INPUT:
- board, il tabellone di gioco dove si svolgerà la partita che va stampato, Board.

LAVORO:
- i, contatore per iterare sul campo squares di board, intero meggiore di zero

ALGORITMO:
i := 1
counter := 1
MENTRE (i < get_dim(board))
  square_j := elemento di squares in posizione j
  SE (square_j = GOOSE_VALUE)
    ALLORA StampareAVideo("x2")
    ALTRIMENTI SE (square_j = BRIDGE_VALUE)
      ALLORA StampareAVideo("ponte")
      ALTRIMENTI SE (square_j = INN_VALUE)
        ALLORA StampareAVideo("locanda")
        ALTRIMENTI SE (square_j = WELL_VALUE)
          ALLORA StampareAVideo("pozzo")
          ALTRIMENTI SE (square_j = LABYRINTH_VALUE)
            ALLORA StampareAVideo("labirinto")
            ALTRIMENTI SE (square_j = PRISON_VALUE)
              ALLORA StampareAVideo("prigione")
              ALTRIMENTI SE (square_j = SKELETON_VALUE)
                ALLORA StampareAVideo("scheletro")
                ALTRIMENTI
                  StampareAVideo(square_j)
              FINE
            FINE
          FINE
        FINE
      FINE
    FINE
  FINE
  counter := counter + 1
  SE (counter = 15)
    ALLORA 
      StampareAVideo(FINE_RIGA)
      counter := 0
  FINE
  i := i + 1
FINE
